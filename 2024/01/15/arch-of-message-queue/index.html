<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>消息队列系统存储架构演进 - Zhihui&#039;s Blog</title><meta name="robots" content="noindex"><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Zhihui&#039;s Blog"><meta name="msapplication-TileImage" content="/img/p.jpeg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Zhihui&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="消息队列（Message Queue）是一种在消息的传递过程中存储消息的机制，广泛应用于系统解耦、流量削峰、数据同步等场景。本文将重点讨论三种流行的消息队列技术的存储架构（RocketMQ、Kafka和Pulsar）以及未来的演变趋势。"><meta property="og:type" content="blog"><meta property="og:title" content="消息队列系统存储架构演进"><meta property="og:url" content="http://zhihuij.github.io/2024/01/15/arch-of-message-queue/"><meta property="og:site_name" content="Zhihui&#039;s Blog"><meta property="og:description" content="消息队列（Message Queue）是一种在消息的传递过程中存储消息的机制，广泛应用于系统解耦、流量削峰、数据同步等场景。本文将重点讨论三种流行的消息队列技术的存储架构（RocketMQ、Kafka和Pulsar）以及未来的演变趋势。"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://zhihuij.github.io/images/rocketmq_store.png"><meta property="og:image" content="http://zhihuij.github.io/images/rocketmq_commit.png"><meta property="og:image" content="http://zhihuij.github.io/images/rocketmq_tieredstorage_arch.png"><meta property="og:image" content="http://zhihuij.github.io/images/kafka_tieredstorage_arch.jpeg"><meta property="og:image" content="http://zhihuij.github.io/images/pulsar_arch.png"><meta property="og:image" content="http://zhihuij.github.io/images/pulsar_distributedlog.png"><meta property="og:image" content="http://zhihuij.github.io/images/pulsar_bookkeeper_segment.png"><meta property="og:image" content="http://zhihuij.github.io/images/mq_storage_choice.png"><meta property="article:published_time" content="2024-01-15T01:25:51.000Z"><meta property="article:author" content="Zhihui"><meta property="article:tag" content="rocketmq"><meta property="article:tag" content="kafka"><meta property="article:tag" content="pulsar"><meta property="article:tag" content="object store"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://zhihuij.github.io/images/rocketmq_store.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://zhihuij.github.io/2024/01/15/arch-of-message-queue/"},"headline":"消息队列系统存储架构演进","image":["http://zhihuij.github.io/images/rocketmq_store.png","http://zhihuij.github.io/images/rocketmq_commit.png","http://zhihuij.github.io/images/rocketmq_tieredstorage_arch.png","http://zhihuij.github.io/images/pulsar_arch.png","http://zhihuij.github.io/images/pulsar_distributedlog.png","http://zhihuij.github.io/images/pulsar_bookkeeper_segment.png","http://zhihuij.github.io/images/mq_storage_choice.png"],"datePublished":"2024-01-15T01:25:51.000Z","author":{"@type":"Person","name":"Zhihui"},"publisher":{"@type":"Organization","name":"Zhihui's Blog","logo":{"@type":"ImageObject","url":"http://zhihuij.github.io/img/p.jpeg"}},"description":"消息队列（Message Queue）是一种在消息的传递过程中存储消息的机制，广泛应用于系统解耦、流量削峰、数据同步等场景。本文将重点讨论三种流行的消息队列技术的存储架构（RocketMQ、Kafka和Pulsar）以及未来的演变趋势。"}</script><link rel="canonical" href="http://zhihuij.github.io/2024/01/15/arch-of-message-queue/"><link rel="icon" href="/img/p.jpeg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/p.jpeg" alt="Zhihui&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-01-15T01:25:51.000Z" title="2024/1/15 09:25:51">2024-01-15</time></span><span class="level-item"><a class="link-muted" href="/categories/Middleware/">Middleware</a><span> / </span><a class="link-muted" href="/categories/Middleware/MQ/">MQ</a></span><span class="level-item">19 minutes read (About 2915 words)</span></div></div><h1 class="title is-3 is-size-4-mobile">消息队列系统存储架构演进</h1><div class="content"><p>消息队列（Message Queue）是一种在消息的传递过程中存储消息的机制，广泛应用于系统解耦、流量削峰、数据同步等场景。本文将重点讨论三种流行的消息队列技术的存储架构（RocketMQ、Kafka和Pulsar）以及未来的演变趋势。</p>
<span id="more"></span>

<h2 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h2><p>RocketMQ是阿里巴巴开源的消息中间件，基于高性能、高吞吐量设计。它采用了分布式、队列模型，能够保证消息的可靠传输。</p>
<h3 id="存储架构"><a href="#存储架构" class="headerlink" title="存储架构"></a><a target="_blank" rel="noopener" href="https://github.com/apache/rocketmq/blob/develop/docs/cn/design.md">存储架构</a></h3><img src="/images/rocketmq_store.png" />

<p>消息存储架构图中主要有下面三个跟消息存储相关的文件构成。</p>
<ul>
<li><p><strong>CommitLog</strong>：消息主体以及元数据的存储主体，存储Producer端写入的消息主体内容，消息内容不是定长的。单个文件大小默认1G， 文件名长度为20位，左边补零，剩余为起始偏移量，比如00000000000000000000代表了第一个文件，起始偏移量为0，文件大小为1G&#x3D;1073741824；当第一个文件写满了，第二个文件为00000000001073741824，起始偏移量为1073741824，以此类推。消息主要是顺序写入日志文件，当文件满了，写入下一个文件；</p>
<img src="/images/rocketmq_commit.png" />
</li>
<li><p><strong>ConsumeQueue</strong>：消息消费索引，引入的目的主要是提高消息消费的性能。由于RocketMQ是基于主题topic的订阅模式，消息消费是针对主题进行的，如果要遍历commitlog文件，根据topic检索消息是非常低效的。Consumer可根据ConsumeQueue来查找待消费的消息。其中，ConsumeQueue作为消费消息的索引，保存了指定Topic下的队列消息在CommitLog中的起始物理偏移量offset，消息大小size和消息Tag的HashCode值。</p>
</li>
<li><p><strong>IndexFile</strong>：IndexFile（索引文件）提供了一种可以通过key或时间区间来查询消息的方法。Index文件的存储位置是：$HOME&#x2F;store&#x2F;index&#x2F;{fileName}，文件名fileName是以创建时的时间戳命名的，固定的单个IndexFile文件大小约为400M，一个IndexFile可以保存 2000W个索引，IndexFile的底层存储设计为在文件系统中实现HashMap结构，故RocketMQ的索引文件其底层实现为hash索引。</p>
</li>
</ul>
<h3 id="分层存储"><a href="#分层存储" class="headerlink" title="分层存储"></a><a target="_blank" rel="noopener" href="https://github.com/apache/rocketmq/blob/develop/tieredstore/README.md">分层存储</a></h3><blockquote>
<p>RocketMQ tiered storage allows users to offload message data from the local disk to other cheaper and larger storage mediums. So that users can extend the message reserve time at a lower cost. And different topics can flexibly specify different TTL as needed.</p>
</blockquote>
<img src="/images/rocketmq_tieredstorage_arch.png" />

<h3 id="高可用机制"><a href="#高可用机制" class="headerlink" title="高可用机制"></a>高可用机制</h3><p>Master&#x2F;Slave</p>
<ol>
<li>Slave通过HAClient向Master上报同步到的最新commitOffset，HAConnection.ReadSocketService（Master）记录各个slave的同步位置；</li>
<li>HAConnection.WriteSocketService（Master）不断检测slaveRequestOffset是否落后于Master最新offset，如果落后，则向Slave传输最新的commit log；</li>
<li>写入消息到本地commitLog后，如果Master是Master_SYNC，则会触发一次Master到Slave的数据传输，Slave收到最新commitLog后，立即向Master汇报最新的offset，Master收到匹配的最新offset后，向客户端返回Master&#x2F;Slave写入成功。</li>
</ol>
<h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><p>Kafka由LinkedIn开发，后成为Apache项目。它是一个分布式流处理平台。</p>
<h3 id="存储架构-1"><a href="#存储架构-1" class="headerlink" title="存储架构"></a>存储架构</h3><p>与RocketMQ最大的不同是，Kafka每一个topic有一个独立的commitlog文件，而RocketMQ是所有topic共享一个，这可能与RocketMQ及Kafka在设计时的初衷有关：Kafka定位于大规模数据或者说日志处理系统，topic不会很多，而RocketMQ定位于服务于业务的消息系统，天然的需要不同的topic来隔离不同的业务，而对Kafka来讲，更多的topic带来更多的文件句柄消耗，以及从单一的文件顺利读写变成随机读写，对性能影响很大。</p>
<h4 id="Partition"><a href="#Partition" class="headerlink" title="Partition"></a>Partition</h4><p>Partition提供并行处理的能力，Partition是最小并发粒度。但更多的partition也会带来问题：</p>
<ul>
<li>More Partitions Lead to Higher Throughput；</li>
<li>More Partitions Requires More Open File Handles：two files，one for the index and another for the actual data per log segment；</li>
<li>More Partitions May Increase Unavailability：when a broker is shut down uncleanly (e.g., kill -9), the observed unavailability could be proportional to the number of partitions（每个partition都需要切主，更多的partition需要更多的时间完成切主，对于排在最后的partition，不可用的时间变长）；</li>
<li>More Partitions May Increase End-to-end Latency：By default, a Kafka broker only uses a single thread to replicate data from another broker, for all partitions that share replicas between the two brokers.（相同的broker之间，默认只有一个同步线程，更多的partition需要更多的时间同步）</li>
<li>More Partitions May Require More Memory In the Client：客户端缓存；</li>
</ul>
<h3 id="分层存储-1"><a href="#分层存储-1" class="headerlink" title="分层存储"></a><a target="_blank" rel="noopener" href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-405%3A+Kafka+Tiered+Storage">分层存储</a></h3><img src="/images/kafka_tieredstorage_arch.jpeg" />

<h3 id="高可用机制：ISR"><a href="#高可用机制：ISR" class="headerlink" title="高可用机制：ISR"></a>高可用机制：ISR</h3><p>Kafka的数据复制是以Partition为单位的。而多个备份间的数据复制，通过Follower向Leader拉取数据完成。从一这点来讲，Kafka的数据复制方案接近于Master-Slave方案。不同的是，Kafka既不是完全的同步复制，也不是完全的异步复制，而是基于ISR的动态复制方案。<br>ISR，也即In-sync Replica。每个Partition的Leader都会维护这样一个列表，该列表中，包含了所有与之同步的Replica（包含Leader自己）。每次数据写入时，只有ISR中的所有Replica都复制完，Leader才会将其置为Commit，它才能被Consumer所消费。</p>
<h4 id="如何选主？"><a href="#如何选主？" class="headerlink" title="如何选主？"></a>如何选主？</h4><p>ISR中的broker先到先得，谁先在ZK上注册信息，谁就是leader。。。</p>
<h4 id="如何判断某个Follower是否“跟上”Leader？"><a href="#如何判断某个Follower是否“跟上”Leader？" class="headerlink" title="如何判断某个Follower是否“跟上”Leader？"></a>如何判断某个Follower是否“跟上”Leader？</h4><ul>
<li>0.8.x版本，如果Follower在replica.lag.time.max.ms时间内未向Leader发送Fetch请求（也即数据复制请求），则Leader会将其从ISR中移除。如果某Follower持续向Leader发送Fetch请求，但是它与Leader的数据差距在replica.lag.max.messages以上，也会被Leader从ISR中移除。</li>
<li>0.9.0.0版本及以上，replica.lag.max.messages被移除；</li>
</ul>
<h4 id="为什么使用ISR？跟Raft，Paxos之类的Majority-Quorum相比有什么区别？"><a href="#为什么使用ISR？跟Raft，Paxos之类的Majority-Quorum相比有什么区别？" class="headerlink" title="为什么使用ISR？跟Raft，Paxos之类的Majority Quorum相比有什么区别？"></a>为什么使用ISR？跟Raft，Paxos之类的Majority Quorum相比有什么区别？</h4><ul>
<li>由于Leader可移除不能及时与之同步的Follower，故与同步复制相比可避免最慢的Follower拖慢整体速度，也即ISR提高了系统可用性；</li>
<li>ISR中的所有Follower都包含了所有Commit过的消息，而只有Commit过的消息才会被Consumer消费，故从Consumer的角度而言，ISR中的所有Replica都始终处于同步状态，从而与异步复制方案相比提高了数据一致性。</li>
<li>ISR可动态调整，极限情况下，可以只包含Leader，极大提高了可容忍的宕机的Follower的数量。与Majority Quorum方案相比，容忍相同个数的节点失败，所要求的总节点数少了近一半。</li>
</ul>
<h2 id="Pulsar"><a href="#Pulsar" class="headerlink" title="Pulsar"></a>Pulsar</h2><p>Pulsar是由Yahoo开发的一个分布式发布订阅消息系统。</p>
<h3 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h3><img src="/images/pulsar_arch.png" />
相比 RocketMQ 以及 Kafka，Pulsar 最大的不同是，从一开始就是计算存储分离的架构，broker 不再负责存储，存储完全由 bookkeeper 来负责，消息的高可用保证也完全由 bookkeeper 来保证。

<h3 id="存储架构-2"><a href="#存储架构-2" class="headerlink" title="存储架构"></a>存储架构</h3><img src="/images/pulsar_distributedlog.png" />

<img src="/images/pulsar_bookkeeper_segment.png" />

<h2 id="未来架构演变"><a href="#未来架构演变" class="headerlink" title="未来架构演变"></a>未来架构演变</h2><h3 id="计算存储分离"><a href="#计算存储分离" class="headerlink" title="计算存储分离"></a>计算存储分离</h3><p>有了 Pulsar 的计算存储分离架构后，RocketMQ 及 Kafka 都开始做类似的架构调整，也就是 Tiered Storage，少量数据存储在本地磁盘，大量或者历史数据存储到对象存储。</p>
<p>计算存储分离的架构有哪些好处呢？</p>
<ul>
<li>Topic的容量可以无限扩张，不再受限于单个物理资源，你可以想一下基于本地磁盘版的 Kafka 做一个 SaaS 化的消息队列（类似 AWS 的 Kinesis）要怎么做？</li>
<li>集群的伸缩不再需要数据迁移（或者rebalance）：这意味着集群可以快速扩容，在出现故障时，异常恢复时间也显著降低；</li>
<li>计算能力及存储能力可以独立扩展，对于消息的读写也可以独立扩展。</li>
</ul>
<h3 id="无盘化架构"><a href="#无盘化架构" class="headerlink" title="无盘化架构"></a>无盘化架构</h3><p>23.7 月，创业公司 Warpstream 发表了一篇文章 <a target="_blank" rel="noopener" href="https://www.warpstream.com/blog/kafka-is-dead-long-live-kafka">Kafka is dead, long live Kafka</a> 主要吐槽了 Kafka 的架构在云环境下的成本问题：存储资源成本，高可用需要的数据复制带来的网络带宽成本，以及复杂的运维成本。为了解决这个问题，他们提出一个完全基于 AWS S3 的架构方案，可以把成本降到 1&#x2F;10 甚至更少，但要牺牲延时（标准版 S3 的单次操作的延时在 100~200ms）。相比云盘，一方面显著降低资源及网络带宽成本，另一方面，因为整个存储都依赖 S3，可用性得到保证，并且运维成本显著降低。在实现上有两个关键点：</p>
<ul>
<li>写入：有一个写入缓存，看他们创始人回答的一些信息来看，大概每 4MB 或者每 250ms 写入一次 S3；</li>
<li>读取：预读取缓存</li>
</ul>
<p>23.11 月 AWS 发布了 S3 Express One Zone，成本高一点，但将单次操作的延时降到 10ms 以内，这个架构的可行性更高了。Warpstream 又发表了一篇 <a target="_blank" rel="noopener" href="https://www.warpstream.com/blog/s3-express-is-all-you-need">S3 Express is All You Need</a> ，对延时有要求的场景，可以使用 S3 Express 来覆盖，但要付出相比 S3 Standard 更高的成本。</p>
<p>差不多同一时间，有位大神写了篇对着干的文章：<a target="_blank" rel="noopener" href="https://jack-vanlightly.com/blog/2023/11/29/s3-express-one-zone-not-quite-what-i-hoped-for">S3 Express One Zone, Not Quite What I Hoped For</a>，文章主要的关注点是 S3 Express 的价格偏高，还不够便宜。但作者还是认为 S3 是现代云原生数据系统实现的重要基础，并且对当前的数据系统方案进行了很好的总结：<br><img src="/images/mq_storage_choice.png" /></p>
<p>现在的 RocketMQ 及 Kafka 处于第一种解决方案阶段，更在向第二种解决方案，也就是 Tiered Storage 演进。国内阿里云的消息队列核心研发创立的 AutoMQ，也是第二种解决方案，主要的方向就是基于 OSS 降低成本，看看他们的宣传语：</p>
<blockquote>
<p>Automate everything that powers OSS Kafka, RocketMQ and RabbitMQ into the cloud-native era with AutoMQ. <strong>Reduce your cloud infrastructure bill by up to 90%</strong>.</p>
</blockquote>
<p>Warpstream 目前属于第三种解决方案。<br>第四种方案，也就是以 S3 之类的对象存储为基础，随着 S3 Express 的性能提升及价格降低，完全无盘化的架构可能会成为趋势，形成一个 S3 Express + S3 Standard 的分层构架，S3 Express 解决延时问题，S3 Standard 解决成本问题。<br>从研发的角度来看，存储完全 offload 到 S3，不但架构更清晰，代码也会更简单，上面介绍的 RocketMQ 及 Kafka 为了高可用而做的大量代码可能都不需要了。</p>
<!-- flag of hidden posts --></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/rocketmq/">rocketmq</a><a class="link-muted mr-2" rel="tag" href="/tags/kafka/">kafka</a><a class="link-muted mr-2" rel="tag" href="/tags/pulsar/">pulsar</a><a class="link-muted mr-2" rel="tag" href="/tags/object-store/">object store</a></div><!--!--></article></div><!--!--><div class="card"><div class="card-content"><h3 class="title is-5">Comments</h3><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div><script>var disqus_config = function () {
            this.page.url = 'http://zhihuij.github.io/2024/01/15/arch-of-message-queue/';
            this.page.identifier = '2024/01/15/arch-of-message-queue/';
        };
        (function() {
            var d = document, s = d.createElement('script');  
            s.src = '//' + 'onlychoice' + '.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/p.jpeg" alt="Zhihui Jiao"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Zhihui Jiao</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">12</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">6</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">15</p></a></div></div></nav></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#RocketMQ"><span class="level-left"><span class="level-item">RocketMQ</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#存储架构"><span class="level-left"><span class="level-item">存储架构</span></span></a></li><li><a class="level is-mobile" href="#分层存储"><span class="level-left"><span class="level-item">分层存储</span></span></a></li><li><a class="level is-mobile" href="#高可用机制"><span class="level-left"><span class="level-item">高可用机制</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Kafka"><span class="level-left"><span class="level-item">Kafka</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#存储架构-1"><span class="level-left"><span class="level-item">存储架构</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Partition"><span class="level-left"><span class="level-item">Partition</span></span></a></li></ul></li><li><a class="level is-mobile" href="#分层存储-1"><span class="level-left"><span class="level-item">分层存储</span></span></a></li><li><a class="level is-mobile" href="#高可用机制：ISR"><span class="level-left"><span class="level-item">高可用机制：ISR</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#如何选主？"><span class="level-left"><span class="level-item">如何选主？</span></span></a></li><li><a class="level is-mobile" href="#如何判断某个Follower是否“跟上”Leader？"><span class="level-left"><span class="level-item">如何判断某个Follower是否“跟上”Leader？</span></span></a></li><li><a class="level is-mobile" href="#为什么使用ISR？跟Raft，Paxos之类的Majority-Quorum相比有什么区别？"><span class="level-left"><span class="level-item">为什么使用ISR？跟Raft，Paxos之类的Majority Quorum相比有什么区别？</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#Pulsar"><span class="level-left"><span class="level-item">Pulsar</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#整体架构"><span class="level-left"><span class="level-item">整体架构</span></span></a></li><li><a class="level is-mobile" href="#存储架构-2"><span class="level-left"><span class="level-item">存储架构</span></span></a></li></ul></li><li><a class="level is-mobile" href="#未来架构演变"><span class="level-left"><span class="level-item">未来架构演变</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#计算存储分离"><span class="level-left"><span class="level-item">计算存储分离</span></span></a></li><li><a class="level is-mobile" href="#无盘化架构"><span class="level-left"><span class="level-item">无盘化架构</span></span></a></li></ul></li></ul></div></div><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/btrace/"><span class="tag">btrace</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/concurrent/"><span class="tag">concurrent</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/elf/"><span class="tag">elf</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/erlang/"><span class="tag">erlang</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ha/"><span class="tag">ha</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/inode/"><span class="tag">inode</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/io/"><span class="tag">io</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/java/"><span class="tag">java</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/linux/"><span class="tag">linux</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/llm/"><span class="tag">llm</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/lock/"><span class="tag">lock</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/rabbitmq/"><span class="tag">rabbitmq</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/slm/"><span class="tag">slm</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/storage/"><span class="tag">storage</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/tcp/"><span class="tag">tcp</span><span class="tag">1</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/p.jpeg" alt="Zhihui&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2024 Zhihui</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>