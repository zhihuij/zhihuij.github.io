<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>消息队列系统存储架构演进 - Zhihui&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Zhihui&#039;s Blog"><meta name="msapplication-TileImage" content="/img/p.jpeg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Zhihui&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="消息队列（Message Queue）是一种在消息的传递过程中存储消息的机制，广泛应用于系统解耦、流量削峰、数据同步等场景。本文将重点讨论三种流行的消息队列技术的存储架构（RocketMQ、Kafka和Pulsar）以及当前的演变趋势。"><meta property="og:type" content="blog"><meta property="og:title" content="消息队列系统存储架构演进"><meta property="og:url" content="http://zhihuij.github.io/2024/01/21/arch-of-message-queue/"><meta property="og:site_name" content="Zhihui&#039;s Blog"><meta property="og:description" content="消息队列（Message Queue）是一种在消息的传递过程中存储消息的机制，广泛应用于系统解耦、流量削峰、数据同步等场景。本文将重点讨论三种流行的消息队列技术的存储架构（RocketMQ、Kafka和Pulsar）以及当前的演变趋势。"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://zhihuij.github.io/images/rocketmq_store.png"><meta property="og:image" content="http://zhihuij.github.io/images/rocketmq_commit.png"><meta property="og:image" content="http://zhihuij.github.io/images/kafka_storage.png"><meta property="og:image" content="http://zhihuij.github.io/images/pulsar_arch.png"><meta property="og:image" content="http://zhihuij.github.io/images/pulsar_bookkeeper_segment.png"><meta property="og:image" content="http://zhihuij.github.io/images/rocketmq_tieredstorage_arch.png"><meta property="og:image" content="http://zhihuij.github.io/images/kafka_tieredstorage_arch.jpeg"><meta property="og:image" content="http://zhihuij.github.io/images/mq_storage_choice.png"><meta property="article:published_time" content="2024-01-21T01:25:51.000Z"><meta property="article:author" content="Zhihui"><meta property="article:tag" content="rocketmq"><meta property="article:tag" content="kafka"><meta property="article:tag" content="pulsar"><meta property="article:tag" content="object store"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://zhihuij.github.io/images/rocketmq_store.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://zhihuij.github.io/2024/01/21/arch-of-message-queue/"},"headline":"消息队列系统存储架构演进","image":["http://zhihuij.github.io/images/rocketmq_store.png","http://zhihuij.github.io/images/rocketmq_commit.png","http://zhihuij.github.io/images/kafka_storage.png","http://zhihuij.github.io/images/pulsar_arch.png","http://zhihuij.github.io/images/pulsar_bookkeeper_segment.png","http://zhihuij.github.io/images/rocketmq_tieredstorage_arch.png","http://zhihuij.github.io/images/mq_storage_choice.png"],"datePublished":"2024-01-21T01:25:51.000Z","author":{"@type":"Person","name":"Zhihui"},"publisher":{"@type":"Organization","name":"Zhihui's Blog","logo":{"@type":"ImageObject","url":"http://zhihuij.github.io/img/p.jpeg"}},"description":"消息队列（Message Queue）是一种在消息的传递过程中存储消息的机制，广泛应用于系统解耦、流量削峰、数据同步等场景。本文将重点讨论三种流行的消息队列技术的存储架构（RocketMQ、Kafka和Pulsar）以及当前的演变趋势。"}</script><link rel="canonical" href="http://zhihuij.github.io/2024/01/21/arch-of-message-queue/"><link rel="icon" href="/img/p.jpeg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/p.jpeg" alt="Zhihui&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-01-21T01:25:51.000Z" title="2024/1/21 09:25:51">2024-01-21</time></span><span class="level-item"><a class="link-muted" href="/categories/Middleware/">Middleware</a><span> / </span><a class="link-muted" href="/categories/Middleware/MQ/">MQ</a></span><span class="level-item">25 minutes read (About 3762 words)</span></div></div><h1 class="title is-3 is-size-4-mobile">消息队列系统存储架构演进</h1><div class="content"><p>消息队列（Message Queue）是一种在消息的传递过程中存储消息的机制，广泛应用于系统解耦、流量削峰、数据同步等场景。本文将重点讨论三种流行的消息队列技术的存储架构（RocketMQ、Kafka和Pulsar）以及当前的演变趋势。</p>
<span id="more"></span>

<h2 id="RocketMQ-存储"><a href="#RocketMQ-存储" class="headerlink" title="RocketMQ 存储"></a>RocketMQ 存储</h2><p>RocketMQ是阿里巴巴开源的消息中间件，基于高性能、高吞吐量设计。它采用了分布式、队列模型，能够保证消息的可靠传输。</p>
<h3 id="存储架构"><a href="#存储架构" class="headerlink" title="存储架构"></a><a target="_blank" rel="noopener" href="https://github.com/apache/rocketmq/blob/develop/docs/cn/design.md">存储架构</a></h3><img src="/images/rocketmq_store.png" />

<p>消息存储架构图中主要有下面三个跟消息存储相关的文件构成。</p>
<ul>
<li><p><strong>CommitLog</strong>：所有topic共享一个文件（逻辑上一个文件，物理上按固定大小分割成多个文件），是消息主体以及元数据的存储主体，存储Producer端写入的消息主体内容，消息内容不是定长的。单个文件大小默认1G， 文件名长度为20位，左边补零，剩余为起始偏移量，比如00000000000000000000代表了第一个文件，起始偏移量为0，文件大小为1G&#x3D;1073741824；当第一个文件写满了，第二个文件为00000000001073741824，起始偏移量为1073741824，以此类推。消息主要是顺序写入日志文件，当文件满了，写入下一个文件；</p>
<img src="/images/rocketmq_commit.png" />
</li>
<li><p><strong>ConsumeQueue</strong>：消息消费索引，引入的目的主要是提高消息消费的性能。由于RocketMQ是基于主题topic的订阅模式，消息消费是针对主题进行的，如果要遍历commitlog文件，根据topic检索消息是非常低效的。Consumer可根据ConsumeQueue来查找待消费的消息。其中，ConsumeQueue作为消费消息的索引，保存了指定Topic下的队列消息在CommitLog中的起始物理偏移量offset，消息大小size和消息Tag的HashCode值。</p>
</li>
<li><p><strong>IndexFile</strong>：IndexFile（索引文件）提供了一种可以通过key或时间区间来查询消息的方法。Index文件的存储位置是：$HOME&#x2F;store&#x2F;index&#x2F;{fileName}，文件名fileName是以创建时的时间戳命名的，固定的单个IndexFile文件大小约为400M，一个IndexFile可以保存 2000W个索引，IndexFile的底层存储设计为在文件系统中实现HashMap结构，故RocketMQ的索引文件其底层实现为hash索引。</p>
</li>
</ul>
<h3 id="高可用机制（Master-Slave）"><a href="#高可用机制（Master-Slave）" class="headerlink" title="高可用机制（Master&#x2F;Slave）"></a>高可用机制（Master&#x2F;Slave）</h3><ol>
<li>Slave通过HAClient向Master上报同步到的最新commitOffset，HAConnection.ReadSocketService（Master）记录各个slave的同步位置；</li>
<li>HAConnection.WriteSocketService（Master）不断检测slaveRequestOffset是否落后于Master最新offset，如果落后，则向Slave传输最新的commit log；</li>
<li>写入消息到本地commitLog后，如果Master是Master_SYNC，则会触发一次Master到Slave的数据传输，Slave收到最新commitLog后，立即向Master汇报最新的offset，Master收到匹配的最新offset后，向客户端返回Master&#x2F;Slave写入成功。</li>
</ol>
<h2 id="Kafka-存储"><a href="#Kafka-存储" class="headerlink" title="Kafka 存储"></a>Kafka 存储</h2><p>Kafka由LinkedIn开发，后成为Apache项目。它是一个分布式流处理平台。</p>
<h3 id="存储架构-1"><a href="#存储架构-1" class="headerlink" title="存储架构"></a>存储架构</h3><p>与RocketMQ最大的不同是，Kafka每一个topic的partition都有一个独立的类似commitlog的文件，而RocketMQ是所有topic共享一个，这与RocketMQ及Kafka在设计时的初衷有关：Kafka定位于大规模数据或者说日志处理系统，topic不会很多，而RocketMQ定位于服务于业务的消息系统，天然的需要不同的topic来隔离不同的业务，而对Kafka来讲，更多的topic带来更多的文件句柄消耗，以及从单一的文件顺利读写变成随机读写，对性能影响很大。<br><img src="/images/kafka_storage.png" /><br>每个 partition 存储有三个文件：</p>
<ol>
<li>日志文件（xx.log）：作用与 RocketMQ 的 commitlog 文件类似，保存原始消息数据</li>
<li>索引文件（xx.index）：作用与 RocketMQ 的 consumerqueue 文件类似，保存消息 offset 以及消息物理存储信息（在xx.log文件中的位置）；</li>
<li>TimeIndex 文件（xx.timeindex）：作用与 RocketMQ 的 indexfile 文件类似，保存消息创建时间以及消息物理存储信息（在xx.log文件中的位置），为了支持类似按创建时间搜索或者过滤消息的功能；</li>
</ol>
<h4 id="Partition"><a href="#Partition" class="headerlink" title="Partition"></a>Partition</h4><p>Partition提供并行处理的能力，Partition是最小并发粒度。但更多的partition也会带来问题：</p>
<ul>
<li>More Partitions Lead to Higher Throughput；</li>
<li>More Partitions Requires More Open File Handles：two files，one for the index and another for the actual data per log segment；</li>
<li>More Partitions May Increase Unavailability：when a broker is shut down uncleanly (e.g., kill -9), the observed unavailability could be proportional to the number of partitions（每个partition都需要切主，更多的partition需要更多的时间完成切主，对于排在最后的partition，不可用的时间变长）；</li>
<li>More Partitions May Increase End-to-end Latency：By default, a Kafka broker only uses a single thread to replicate data from another broker, for all partitions that share replicas between the two brokers.（相同的broker之间，默认只有一个同步线程，更多的partition需要更多的时间同步）</li>
<li>More Partitions May Require More Memory In the Client：客户端缓存；</li>
</ul>
<h3 id="高可用机制：ISR"><a href="#高可用机制：ISR" class="headerlink" title="高可用机制：ISR"></a>高可用机制：ISR</h3><p>Kafka的数据复制是以Partition为单位的。而多个备份间的数据复制，通过Follower向Leader拉取数据完成。从一这点来讲，Kafka的数据复制方案接近于Master-Slave方案。不同的是，Kafka既不是完全的同步复制，也不是完全的异步复制，而是基于ISR的动态复制方案。<br>ISR，也即In-sync Replica。每个Partition的Leader都会维护这样一个列表，该列表中，包含了所有与之同步的Replica（包含Leader自己）。每次数据写入时，只有ISR中的所有Replica都复制完，Leader才会将其置为Commit，它才能被Consumer所消费。</p>
<h4 id="如何选主？"><a href="#如何选主？" class="headerlink" title="如何选主？"></a>如何选主？</h4><p>ISR中的broker先到先得，谁先在ZK上注册信息，谁就是leader。</p>
<h4 id="如何判断某个Follower是否“跟上”Leader？"><a href="#如何判断某个Follower是否“跟上”Leader？" class="headerlink" title="如何判断某个Follower是否“跟上”Leader？"></a>如何判断某个Follower是否“跟上”Leader？</h4><ul>
<li>0.8.x版本，如果Follower在replica.lag.time.max.ms时间内未向Leader发送Fetch请求（也即数据复制请求），则Leader会将其从ISR中移除。如果某Follower持续向Leader发送Fetch请求，但是它与Leader的数据差距在replica.lag.max.messages以上，也会被Leader从ISR中移除。</li>
<li>0.9.0.0版本及以上，replica.lag.max.messages被移除；</li>
</ul>
<h4 id="为什么使用ISR？跟Raft，Paxos之类的Majority-Quorum相比有什么区别？"><a href="#为什么使用ISR？跟Raft，Paxos之类的Majority-Quorum相比有什么区别？" class="headerlink" title="为什么使用ISR？跟Raft，Paxos之类的Majority Quorum相比有什么区别？"></a>为什么使用ISR？跟Raft，Paxos之类的Majority Quorum相比有什么区别？</h4><ul>
<li>由于Leader可移除不能及时与之同步的Follower，故与同步复制相比可避免最慢的Follower拖慢整体速度，也即ISR提高了系统可用性；</li>
<li>ISR中的所有Follower都包含了所有Commit过的消息，而只有Commit过的消息才会被Consumer消费，故从Consumer的角度而言，ISR中的所有Replica都始终处于同步状态，从而与异步复制方案相比提高了数据一致性。</li>
<li>ISR可动态调整，极限情况下，可以只包含Leader，极大提高了可容忍的宕机的Follower的数量。与Majority Quorum方案相比，容忍相同个数的节点失败，所要求的总节点数少了近一半。</li>
</ul>
<h2 id="Pulsar-存储"><a href="#Pulsar-存储" class="headerlink" title="Pulsar 存储"></a>Pulsar 存储</h2><p>Pulsar是由Yahoo开发的一个分布式发布订阅消息系统。</p>
<h3 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h3><img src="/images/pulsar_arch.png" />
相比 RocketMQ 以及 Kafka，Pulsar 最大的不同是，从一开始就是计算存储分离的架构，broker 不再负责存储，存储完全由 bookkeeper 来负责，消息的高可用保证也完全由 bookkeeper 来提供。BookKeeper是一个高可靠性和高性能的分布式日志存储系统。

<h3 id="存储架构-2"><a href="#存储架构-2" class="headerlink" title="存储架构"></a>存储架构</h3><p>基本概念：</p>
<blockquote>
<p><strong>ledger</strong>: streams of log entries are called ledgers<br><strong>bookie</strong>: individual servers storing ledgers of entries are called bookies</p>
</blockquote>
<p>在Pulsar中，每个Topic的消息存储在一个或多个Ledger中。当一个Ledger达到一定的大小或时间阈值，Pulsar会关闭当前Ledger并创建一个新的Ledger。Ledger 可以被拆分成多个 Segment，为了保障存储的高可用，每个 Segment 一般都会被分布到多台机器上。<br><img src="/images/pulsar_bookkeeper_segment.png" /></p>
<h2 id="架构演变趋势"><a href="#架构演变趋势" class="headerlink" title="架构演变趋势"></a>架构演变趋势</h2><h3 id="计算存储分离"><a href="#计算存储分离" class="headerlink" title="计算存储分离"></a>计算存储分离</h3><p>Pulsar 是完全的计算存储分离架构，计算由 broker 来做，存储完成交给 bookkeeper。<br>计算存储分离在架构上的好处有哪些呢？</p>
<ul>
<li>Topic的容量可以无限扩张，不再受限于单个物理资源，你可以想一下基于本地磁盘版的 Kafka 做一个 SaaS 化的消息队列（类似 AWS 的 Kinesis）要怎么做？</li>
<li>集群的伸缩不再需要数据迁移（或者rebalance）：这意味着集群可以快速扩容，在出现故障时，异常恢复时间也显著降低；</li>
<li>计算能力及存储能力可以独立扩展，对于消息的读写也可以独立扩展。</li>
</ul>
<h3 id="分层存储"><a href="#分层存储" class="headerlink" title="分层存储"></a>分层存储</h3><p>RocketMQ 及 Kafka 为了支持计算存储分离的架构，采取了一个相对折中的策略：分层存储（tiered storage）。</p>
<p>分层存储架构（Tiered Storage）是一种高效的数据存储和管理方法，旨在优化存储系统的性能和成本效率。在这种架构中，数据被分散存储在不同类型的存储介质上，这些介质按照性能和成本的不同分为几个层级。这是一种通用的存储架构模式，不止是消息系统，数据库系统中也经常使用。</p>
<p>最主要的两个层级是热存储（Hot Storage）和冷存储（Cold Storage）。热存储通常使用更快速的存储介质，如SSD（固态硬盘），用于存储频繁访问的数据，以确保高性能和快速响应。相比之下，冷存储则使用成本较低的存储介质，如HDD（硬盘驱动器）或者远程存储（对象存储，HDFS等之类的），适用于存放访问频率较低的数据。</p>
<p>分层存储的关键优势在于它能够平衡性能和成本。通过将最活跃的数据保存在高性能的存储中，同时将较少使用的数据迁移到成本更低的存储上，可以在保证高效消息处理的同时，降低总体的存储成本。</p>
<h4 id="RocketMQ-分层存储"><a href="#RocketMQ-分层存储" class="headerlink" title="RocketMQ 分层存储"></a><a target="_blank" rel="noopener" href="https://github.com/apache/rocketmq/blob/develop/tieredstore/README.md">RocketMQ 分层存储</a></h4><blockquote>
<p>RocketMQ tiered storage allows users to offload message data from the local disk to other cheaper and larger storage mediums. So that users can extend the message reserve time at a lower cost. And different topics can flexibly specify different TTL as needed.<br><img src="/images/rocketmq_tieredstorage_arch.png" /></p>
</blockquote>
<h4 id="Kafka-分层存储"><a href="#Kafka-分层存储" class="headerlink" title="Kafka 分层存储"></a><a target="_blank" rel="noopener" href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-405%3A+Kafka+Tiered+Storage">Kafka 分层存储</a></h4><img src="/images/kafka_tieredstorage_arch.jpeg" />

<h3 id="无盘化架构"><a href="#无盘化架构" class="headerlink" title="无盘化架构"></a>无盘化架构</h3><p>无盘化也是计算存储分离架构，但不再依赖于本地磁盘或者云盘，而是完全依赖远程对象存储。</p>
<p>23.7 月，创业公司 Warpstream 发表了一篇文章 <a target="_blank" rel="noopener" href="https://www.warpstream.com/blog/kafka-is-dead-long-live-kafka">Kafka is dead, long live Kafka</a> 主要吐槽了 Kafka 的架构在云环境下的成本问题：存储资源成本，高可用需要的数据复制带来的网络带宽成本，以及复杂的运维成本。为了解决这个问题，他们提出一个完全基于 AWS S3 的架构方案，可以把成本降到 1&#x2F;10 甚至更少，但要牺牲延时（标准版 S3 的单次操作的延时在 100~200ms）。相比云盘，一方面显著降低资源及网络带宽成本，另一方面，因为整个存储都依赖 S3，可用性得到保证，并且运维成本显著降低。在实现上有两个关键点：</p>
<ul>
<li>写入：有一个写入缓存，看他们创始人回答的一些信息来看，大概每 4MB 或者每 250ms 写入一次 S3；</li>
<li>读取：消息数据按一定策略分散到所有 broker 上，消费时直接从 broker 读取，broker 按需从 S3 读取，并且需要有预读取的能力。</li>
</ul>
<p>23.11 月 AWS 发布了 S3 Express One Zone，成本高一点，但将单次操作的延时降到 10ms 以内，这个架构的可行性更高了。Warpstream 又发表了一篇 <a target="_blank" rel="noopener" href="https://www.warpstream.com/blog/s3-express-is-all-you-need">S3 Express is All You Need</a> ，对延时有要求的场景，可以使用 S3 Express 来覆盖，但要付出相比 S3 Standard 更高的成本。</p>
<p>差不多同一时间，有位大神写了篇总结性很强的文章：<a target="_blank" rel="noopener" href="https://jack-vanlightly.com/blog/2023/11/29/s3-express-one-zone-not-quite-what-i-hoped-for">S3 Express One Zone, Not Quite What I Hoped For</a>，文章认可 S3 是现代云原生数据系统实现的重要基础，但当前 S3 Express 的价格偏高，还不够便宜。这篇文章对当前云原生数据系统的架构方案进行了很好的总结：<br><img src="/images/mq_storage_choice.png" /></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>现在的 RocketMQ 及 Kafka 处于第一种解决方案阶段，正在向第二种解决方案，也就是 Tiered Storage 演进。国内阿里云的消息队列核心研发创立的 AutoMQ，也是第二种解决方案，主要的方向就是基于 OSS 降低成本，看看他们的宣传语：</p>
<blockquote>
<p>Automate everything that powers OSS Kafka, RocketMQ and RabbitMQ into the cloud-native era with AutoMQ. <strong>Reduce your cloud infrastructure bill by up to 90%</strong>.</p>
</blockquote>
<p>Warpstream 目前属于第三种解决方案。</p>
<p>第四种方案，也就是以 S3 为基础，形成一个 S3 Express + S3 Standard 的分层构架：S3 Express 解决延时问题，S3 Standard 解决成本问题，会随着 S3 Express 的性能提升及价格降低，形成一个完全无盘化的架构趋势。</p>
<p>从研发的角度来看，存储完全依赖 S3，不但架构更清晰，代码也会更简单，上面介绍的 RocketMQ 及 Kafka 为了高可用而做的大量代码可能都不需要了。从运维的角度看，成本也是大幅降低，S3 本身有 SLA 保障，由云平台来运维，用户只需要维护无状态的计算结点，故障恢复逻辑也简单很多。</p>
</div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/rocketmq/">rocketmq</a><a class="link-muted mr-2" rel="tag" href="/tags/kafka/">kafka</a><a class="link-muted mr-2" rel="tag" href="/tags/pulsar/">pulsar</a><a class="link-muted mr-2" rel="tag" href="/tags/object-store/">object store</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2024/01/14/small-language-model/"><span class="level-item">小模型（Small Language Model）信息汇总</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">Comments</h3><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div><script>var disqus_config = function () {
            this.page.url = 'http://zhihuij.github.io/2024/01/21/arch-of-message-queue/';
            this.page.identifier = '2024/01/21/arch-of-message-queue/';
        };
        (function() {
            var d = document, s = d.createElement('script');  
            s.src = '//' + 'onlychoice' + '.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/p.jpeg" alt="Zhihui Jiao"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Zhihui Jiao</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">13</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">6</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">19</p></a></div></div></nav></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#RocketMQ-存储"><span class="level-left"><span class="level-item">RocketMQ 存储</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#存储架构"><span class="level-left"><span class="level-item">存储架构</span></span></a></li><li><a class="level is-mobile" href="#高可用机制（Master-Slave）"><span class="level-left"><span class="level-item">高可用机制（Master/Slave）</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Kafka-存储"><span class="level-left"><span class="level-item">Kafka 存储</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#存储架构-1"><span class="level-left"><span class="level-item">存储架构</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Partition"><span class="level-left"><span class="level-item">Partition</span></span></a></li></ul></li><li><a class="level is-mobile" href="#高可用机制：ISR"><span class="level-left"><span class="level-item">高可用机制：ISR</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#如何选主？"><span class="level-left"><span class="level-item">如何选主？</span></span></a></li><li><a class="level is-mobile" href="#如何判断某个Follower是否“跟上”Leader？"><span class="level-left"><span class="level-item">如何判断某个Follower是否“跟上”Leader？</span></span></a></li><li><a class="level is-mobile" href="#为什么使用ISR？跟Raft，Paxos之类的Majority-Quorum相比有什么区别？"><span class="level-left"><span class="level-item">为什么使用ISR？跟Raft，Paxos之类的Majority Quorum相比有什么区别？</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#Pulsar-存储"><span class="level-left"><span class="level-item">Pulsar 存储</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#整体架构"><span class="level-left"><span class="level-item">整体架构</span></span></a></li><li><a class="level is-mobile" href="#存储架构-2"><span class="level-left"><span class="level-item">存储架构</span></span></a></li></ul></li><li><a class="level is-mobile" href="#架构演变趋势"><span class="level-left"><span class="level-item">架构演变趋势</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#计算存储分离"><span class="level-left"><span class="level-item">计算存储分离</span></span></a></li><li><a class="level is-mobile" href="#分层存储"><span class="level-left"><span class="level-item">分层存储</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#RocketMQ-分层存储"><span class="level-left"><span class="level-item">RocketMQ 分层存储</span></span></a></li><li><a class="level is-mobile" href="#Kafka-分层存储"><span class="level-left"><span class="level-item">Kafka 分层存储</span></span></a></li></ul></li><li><a class="level is-mobile" href="#无盘化架构"><span class="level-left"><span class="level-item">无盘化架构</span></span></a></li><li><a class="level is-mobile" href="#总结"><span class="level-left"><span class="level-item">总结</span></span></a></li></ul></li></ul></div></div><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/btrace/"><span class="tag">btrace</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/concurrent/"><span class="tag">concurrent</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/elf/"><span class="tag">elf</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/erlang/"><span class="tag">erlang</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ha/"><span class="tag">ha</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/inode/"><span class="tag">inode</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/io/"><span class="tag">io</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/java/"><span class="tag">java</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kafka/"><span class="tag">kafka</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/linux/"><span class="tag">linux</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/llm/"><span class="tag">llm</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/lock/"><span class="tag">lock</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/object-store/"><span class="tag">object store</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/pulsar/"><span class="tag">pulsar</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/rabbitmq/"><span class="tag">rabbitmq</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/rocketmq/"><span class="tag">rocketmq</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/slm/"><span class="tag">slm</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/storage/"><span class="tag">storage</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/tcp/"><span class="tag">tcp</span><span class="tag">1</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/p.jpeg" alt="Zhihui&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2024 Zhihui</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>